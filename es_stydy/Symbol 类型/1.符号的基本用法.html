<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // Symbol（符号）是 ECMAScript 6 新增的数据类型。
        // 符号是原始值，且符号实例是唯一、不可变的。
        // 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。
        // 尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的

        let sym = Symbol();
        console.log(typeof sym); // symbol


        // 调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），
        // 将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：
        let genericSymbol = Symbol();
        let otherGenericSymbol = Symbol();
        let fooSymbol = Symbol('foo');
        let otherFooSymbol = Symbol('foo');
        console.log(genericSymbol == otherGenericSymbol); // false
        console.log(fooSymbol == otherFooSymbol); // false

        // 符号没有字面量语法，这也是它们发挥作用的关键。
        // 按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，
        // 就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。
        let Symbol1 = Symbol();
        console.log(Symbol1); // Symbol() 

        let Symbol2 = Symbol('foo');
        console.log(Symbol2); // Symbol(foo);

        // 最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。
        // 这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，
        // 它们都支持构造函数且可用于初始化包含原始值的包装对象：

        let myBoolean = new Boolean();
        console.log(typeof myBoolean); // "object" 

        let myString = new String();
        console.log(typeof myString); // "object" 

        let myNumber = new Number();
        console.log(typeof myNumber); // "object" 

        // let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor

        // 如果你确实想使用符号包装对象，可以借用 Object()函数：
        let mySymbol = Symbol();
        let myWrappedSymbol = Object(mySymbol);
        console.log(typeof myWrappedSymbol); // "object"
        
    </script>
</body>

</html>